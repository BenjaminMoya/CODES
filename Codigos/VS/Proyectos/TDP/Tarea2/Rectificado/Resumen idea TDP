Un clique en un grafo es un subconjunto de vertices donde cada uno es adyacente a cualquier otro del subconjunto.
Econtrar el tamano de un clique maximo de un grafo dado es un problema NP-hard.
El problema del clique maximo ha sido estudiado en distintas configuraciones de programacion por restrciccion usando algoritmos 
inspirados en MaxSAT.
Sin embargo, nos centraremos en la familia de los algoritmos Branch and Bound, los cuales son usados ampliamente en problemas reales, que ne la practica, hay muchas variciones propuestas, notablemente las versiones que incluyen Bit y Thread-parallel.
Las tecnicas que investigaremos ambien han sido reusadas para resolver otros problemas incluyendo el maximo subgrafo en comun y la maxima
biclique inducida equilibrada
Pero a pesar de este amplio uso, no esta del todo claro poque estos algoritmos funcionan tan bien, en partciular una parte de ellos donde
se itera sobre un cierto array hacia atras.
Es facil revisar que esto lleva a una busqueda reducida en comparacion a una busuqeda hacia adelante del mismo array, pero recientes trabajos experimentales contradicen esta convencional explicacion de porque deberia ser este el caso
Reformulando el algoritmo, usando el idioma de la programaciones restringida, veremos que esas "hacia adelante" y "hacia atras" iteraciones
son eficientes en 2 diferentes heuristicas seleccionadas.
Se han tomado las mediciones dentro de la busqueda para demostrar que el "hacia atras", por coincidencia, aproxima a la heuristica del primer dominio minimo, y el "hacia adelante" a la heuristica del primer dominio mayor.
Es facil de modificar el algotimo para usar un genuino SDF, conduciendolo atraves de una busqueda mas pequena, gracias a la reduccion del factor Branch, pero grandes ejecuciones puede costar rendimiento al realizar una clasificacion en cada llamada recursiva 
Finalmente, mostraremos como conseguir ambas busquedas minimas para mejorar tiempos de ejecuciones usando alternativas baratas de SDF

G=(V,E) va a ser un grafo con un conjunto de vertices V y aristas E. Se escribe V(G) para respresentar V y N(G,v) para los vecinos del vertice v. El tamano de un clique maximo se denota como ω. 
Cuando se discute sobre grafos random se usa G(n,p) para denotar a los grafos random de Erdos-Renyi con n vertices y con aristas entre cada par de vertices distintos con prababilidad p.

Empezamos describiendo el algoritmo 1, uno generico, exactamente el algotritmo de Branch and Bound para el problema del maximo clique. Este algoritmo es esencial, donde con un simple vertice inicial y el paso de coloreo omitido, se describe de una nueva forma, mas flexible con tal de investigra su comportamiento.

La clave de este algoritmo es una relacion entre cliques y coloreo.
El coloreo de un grafo es un asignacion de vertices a colores, donde vertcies adyacente reciben colores distintos.
Un conjunto de vertices del mismmo color en determinado color es llamado como clase de color.
Un clique en un grafo coloreado puede contener como mucho 1 vertcice de cada clase de color, asi que si coloreamos un grafo usando k colores, hemos mostrado que ω <= k, la cual generalmente no es una igualdad.

Algoritmo 1: un algoritmo generico exacto para cliques maximos

maxClique(G) = Conjunto
	goblal Cliquemax = vacio;
	expand(G,vacio,V(G));
	retorno Cliquemax;
expand(G,C,P)
	clasesdecolor = coloreo(G,P);
	mientras clasesdecolor != vacio hacer
		clasedecolor = seleccionar(clasesdecolor)
		para v en clasedecolor hacer
			si el clique actual (C) mas el numero de clases de color restantes no supera Clique maximo entonces puede haber un clique mayor y retorna;
			P' = P intersectado con los vecinos de v que estan en P;
			C' = C union v;
			si el tamano del clique actual (C) es mayor que el de Cliquemax entonces Cliquemax = C;
			si P' es distinto de vacio entonces se llama a expand (G,C',P');
		clasesdecolor = remover clasedecolor de clasesdecolor

Esto es usado para hacer crecer el clique maximo mediante una variable C que contiene el crecimiento del clique actual, la variable P que contiene a los vertices potenciales para ser anadidos en C.
Inicialmente C esta vacio y P contiene cada vertice del grafo .
Ahora se realiza un coloreo del subgrafo mediante P, donde se seleciona una clase de color y un vertice desde esa clase
Ahora considermaos todo clique que contiene los vertices en C mas el vertice seleccionado(v), mediante la filtracion de P con cualquier vertice que no sea adyacente a v.
Luego se considera todo clique que contiene los vertice en C pero no v, removiendolo de las consideraciones y seleccionando un nuevo vertice de la clase de color actual
Cuando la clase de color actual a sido explorada se remueve para considerar las posibilidades de no seleccionar ningun vertice de esta clase de color y para luego seleccionar una nueva clase de color
Realizamos el seguimiento del clique maximo que hemos enocntrado hasta el momento, el cual llamaremos titular y lo guardaremos en Cliquemax
En este punto durante la busqueda, si el numero de clases de color restante mas el numero de vertices en C es estrictamente mayor que el tamano de Cliquemax no podemos reemplazar al titular y tendremos que hacer el backtracking

Algoritmo 2: coloreo de vertices

coloreo(G,P) = Lista de conjuntos
	clasesdecolor = vacio;
	porcolorear = P
	mientras porcolorear != vacio hacer
		actual = vacio;
		para cada vertice en porcolorear hacer
			si actual intersectado con los vecinos del vertice = vacio entonces actual = actual union vertice
		porcolorear= porcolorear - actual
		clasesdecolor = append(clasesdecolor,actual)
	retornar clasesdecolor

Notar que cada recursion crea un nuevo coloreo que generalmente se van haciendo mas pequenas segun consideramos subproblemas mas pequenos.
Por lo que ser capaz de colorear rapidamente es muy importante.
La codificacion en conjunto de bits conduce a que el algoritmo mejora su rendimiento entre dos a veinte veces sin cambiar la secuencia
Se usara una codificacion de bit implicita que se dara detalles mas adelante
En terminos de programacion restringida, podemos pensar en las clases de color como variables y los vertices sin una clase de color como un valor.
Ademas de un "nada de esta clase de color" como valor, que ojala se use lo menos posible
En la linea 10 estaremos seleccioando una variable y en la 11 le estamos intantado dar valor a esta
La linea 13 de filtrado es de propagacion
Existe una ligera complicacion conceptual donde se producen nuevos conjuntos de variables en cada llamada recursiva
Hay 3 opciones que se deben tomar en la implemntacion
La primera es como el coloreo es producido , que el mostrado aplica uno secuencial donde las clases de colores se llenan de vertices en orden y el orden en que los vertices son considerados tiene un gran efecto en como se produce el coloreo, generalmente seleccionados estaticamente donde otros vertices iniciales y coloreos mas sofisticados pueden resultar en mejores resultados e incluso en peores resultados
Notar como la seleccion en orden del vertice esta hecha mejorando la calidad del coloreo espernado que este mismo se acerque al optimo 
Para retos computacionales de grafos, el grado de un vertice a menudo es una indicacion si esta presenta en una solucion, porque la dispersion de grados es muy estrecha o porque los grafos contiene muchos maximos cliques pero la dificultad esta en proveer el optimo
La segunda es en como se selecciona la clase de color y el tercero en el orden de seleccion de los vertices desde la clase seleccionada
Estas elecciones no deben ser investigadas en profundidad 
Para emular el algitmo de Tomitas seleccionaremos y removeremos la ultima clase de color de la lista de clases de color construida y los vertices sin una clase de color seran seleccionados al reves con el ultimo vertice de la clase de color seleccionada como el primero
Esto debe ser implementado eficientemente usando pares de arrays 
El primer arreglo controla el orden de iteracion conteniendo los numeros de los vertices al reves 
El segundo arreglo contiene el Bound 
En la entrada i se guarda el numero de colores que se usaron para colorear el subgrafo inducido que contiene solo los primeros i vertices del primer arreglo
Desde los vertices con el mismo color sean adayacentes en el orden de iteracion, el Bound decae desde derecha a izquierda en la iteracion
De cualquier manera, la recursividad desde izquierda a derecha debe ser implementada eficientemente
Tomita dice que los vertices que estan ene le extremo derecho del color generalmebte se espera tenerlos con una probabilidad alta en el clique maximo
Esta aseveracion no esta comprobada experimentalmente, mas alla de verificar que el orden inverso da un muy bajo rendimiento y recientes experimentos sugiere que para ciertas familias de grafos estos algoritmos no son particularmente rapidos en econtrar el clique maximo
Se argumenta que dbe haber otro factor que contribuya al exito de la seleccion inversa
Intuitivamente uno puede poensar que colorear inicialmente puede ser extenso, pero las clases de color son astutas ya que los vertices son colocados en la primera clase disponible, por lo que seleccionaar desde clases de color pequenas primero es beneficioso considerando y suponiendo que el Cliquemaximo = 3.
Si selecionamos v desde el color en la orilla derecha realizariamos solo una llamada recursiva que no podra ser eleiminada por el Bound
Pero si selecionamos desde cualquier otra clase de color realizaremos entre 2 a 3 llamadas recursivas antes que el Bound decaiga
En terminos de programacion restringida, seleccionar desde la clase de color mas pequena primero es SDF, la cual es una heuristica que tiende a dar un bajo factor local de Branching que reduce el numero de llamadas recursivas, pero que no necesariamente el mejor arbol globlal de busqueda, pero se demuestra que en este contexto generalmente es beneficioso
Ahora probando nuestra intuicion mediante la argumentacion del coloreo con tal de toamr medidadas dentro de la busqueda, la hipotesis que intentaremos probar se correlaciona entre la posicion de la clase de color y la posicion en la que la clase de color deberia estar si estuviese ordenada por tamano. 
Para medir esto usamos el coeficiente del ranking Spearmans el cual nos da un valor entre 1 si existe una relacion perfecta monotona creciente y -1 si es perfecta monotona decreciente 
Se ha realizado pruebas por cad color producido atraves de 100 ejemplos de grafos random
Los resultados confirman las suposiciones de que las clases de color estan ordenadas aproximadamente por tamano por efecto del proceso de coloreo, por lo que este proceso y las iteraciones inversas se aproximan a la heuristica SDF 
Hemos establecido empiricamente que clases de color mas pequenas tienden a ser elegidas antes por el algoritmo de tomitas.
Para reducir el Branching mediante el reordenamiento de las clases de color, se establece empiricamente que las clases de color mas pequenas tienden a ser elegidas antes por el algoritmo de tomitas  y para verificar su impacto podemos considerar dos aproximaciones, la ordenada o la variacion de SDF.
Podemos explicitamente elegir la clase de color mas pequena priumero implementando directamente diferentes vias para la funcion select del primer algoritmo o podemos usar los 2 arrays de tomitas para acercarnos y agragar un orden estable para el fin del algoritmo 2
La variacion del SDF o parcialmente ordenada, se puede considerar como una alternativa potencialmente barata en vezx de ordenar completamente las clases de color por tamano, proponiendo un orden parcial que mueve las clases de color con 1 vertice al final del array con tal de seleccionarlas primero, en otras palabras seleccionaremos dominios con 2 valores primero. 
Ahora mostraremos como hacer esto de manera que sea compatible con el codificador de bits en el algoritmo 3
Cuando se produce una clase de color que contenga un solo vertcie, agregamos esa clase de color en una lista de instancias y cuando todo vertice haya sido procesado se retorna la lista de clases de color concantenada con la lsitas de instancias que aparencienron al final 

Algoritmo 3 
coloreoSDF(G,P) = Lista de conjuntos
	clasesdecolor = vacio
	instancias = vacio
	porcolorear = P
	mientras porcolorear != vacio hacer
	actual = vacio
		para v en porcolorear hacer
			si actual intersectado con los vecinos de v = vacio entonces actual = actual union v
		porcolorear = porcolorear - actual
		si el tamano de actual es 1 entonces
			instancias = append(actual)
		en otro caso
			clasesdecolor = append(actual)
	return concatenar(clasesdecolor,instancias)
	
Ambos cambiaos en los ordenamientos y ordenamientos paraciales son compatibles con otras recientes mejoras que han sido propuestas para esta familia de algoritmos, los cuales no interfieren con la busqueda con una solucion heuristica, siendo no sensibles a alternativas de orden de vertices y criticamente, son compatibles con paralelismo multicore
Una mejora con la que no es compatible es con el coloreo relajado, el cual no interactua correctamente con el Branch and Bound paralelo asi que no podemos considerarlo como una debilidad substancial

